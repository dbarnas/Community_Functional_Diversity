---
title: "SGD Clustering"
author: "Danielle Barnas"
date: "2/6/2022"
output: html_document
---

# Clustering Analysis

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```


## Load Libraries
```{r, results='hide', message=FALSE}

#options('repos' = c(options('repos')$repos, RSPM = "https://my-repo.com/all/latest"))

library(tidyverse)
library(lubridate)
library(VarSelLCM) # LCM - cluster modeling
library(ggmap)
library(PNWColors)
library(here)
library(curl) # pull data from url
library(tidytext) # arrange data in a facet_wrap
library(kableExtra) # create neat tables
library(ggrepel) # labeling
library(ggpmisc) # add R2 to figures
library(patchwork)
 
# API<-names(read_table(here("Data","API.txt")))
# register_google(key = API) ### uses my API in separate txt file


```

## Read in Data
```{r}
## Read in data - biogeochem data processed in Nutrient_Processing script
Full_data<-read_csv(here("Data","Biogeochem","AugNutrient_Processed.csv"))

```
## For cluster analysis, and analyzing community composition in ANOVA style, only use Varari August data to set clusters
#### Due to very low R2 for Varari in March and Cabral in both seasons
```{r}
Full_data <- Full_data %>% 
  filter(Location == "Varari")
head(Full_data)
```



## Histograms

- create a histogram to see distribution and transform whatever isn't normal
- ggridges shows distribution of means vs raw data if I input the means (but raw data can help determine if I should use means or medians or max's etc.)
- summarise, log10 what needs it, then standardize and center, then select important variables



## Check for relationships to salinity and silicate
#### Note: Only use Varari August data for ANOVA style community composition analysis by cluster zones
```{r}
## first check linear relationships with silicate
Full_data %>% 
  filter(CowTagID != "VSEEP") %>% 
  pivot_longer(cols = c(Salinity:Phosphate_umolL, NN_umolL:N_percent), 
               names_to = "Parameters", 
               values_to = "Values") %>% 
  ggplot(aes(x = Silicate_umolL, 
             y = Values,
             #color = Location
             ), color = "black") +
  geom_point() +
  geom_smooth(method = "lm", color = "black") +
  facet_wrap(~Parameters, scales = "free") +
  labs(title = "All parameters ~ Silicate",
       x = "Range of Silicate (umolL)",
       y = "Value Ranges") +
  theme_bw() +
  theme(strip.background = element_rect(fill = "white"))

## Turbinaria nitrogen relationships with silicate <- will show later with R2 values
# Full_data %>% 
#   filter(CowTagID != "VSEEP") %>% 
#   pivot_longer(cols = c(del15N:N_percent), names_to = "Parameters", values_to = "Values") %>% 
#   ggplot(aes(x = Silicate_umolL, 
#              y = Values,
#              #color = Location
#              ), color = "black") +
#   geom_point() +
#   geom_smooth(method = "lm", color = "black") +
#   facet_wrap(~Parameters, scales = "free") +
#   labs(title = "T. ornata Nitrogen ~ Silicate",
#        x = "Range of Silicate (umolL)",
#        y = "Value Ranges") +
#   theme_bw() +
#   theme(strip.background = element_rect(fill = "white"))
```

%N ~ Silicate
```{r}
## N_percent ~ Silicate
# linear model of N_percent with respect to silicate
Vdata <- Full_data %>% 
  filter(CowTagID != "VSEEP")
Vmodel <- lm(data = Vdata, N_percent ~ Silicate_umolL)
# Cdata <- Full_data %>%
#   filter(Location == "Cabral") %>% 
#   filter(CowTagID != "CSEEP")
# Cmodel <- lm(data = Cdata, N_percent ~ Silicate_umolL)

# display r squared values for lm
Vsum <- summary(Vmodel)$r.squared
# Csum <- summary(Cmodel)$r.squared

# graph relationship
fig_N_percent <- Full_data %>% 
  filter(CowTagID != "VSEEP") %>% 
  #select(Location, CowTagID, Silicate_umolL, N_percent) %>% 
  ggplot(aes(x=Silicate_umolL,
             y = N_percent,
             label = CowTagID
             #color = Location)
             ), color = "black") +
  geom_point() +
  geom_text_repel() +
  geom_smooth(method = "lm", color = "black") +
  labs(x = "Range of Silicate (umolL)",
       y = "Range of %N",
       caption = paste("Varari R-squared:",round(Vsum, 2) #, "\n",
                       #"Cabral R-squared:", round(Csum, 2)
                       )) +
  #facet_wrap(~Location, scales = "free") +
  theme_bw() +
  theme(strip.background = element_rect(fill = "white"))

```


C:N Ratio ~ Silicate
```{r}
## C_N ~ Silicate
# linear model of C_N with respect to silicate
Vdata <- Full_data %>% 
  filter(CowTagID != "VSEEP")
Vmodel <- lm(data = Vdata, C_N ~ Silicate_umolL)
# Cdata <- Full_data %>%
#   filter(Location == "Cabral") %>% 
#   filter(CowTagID != "CSEEP")
# Cmodel <- lm(data = Cdata, C_N ~ Silicate_umolL)

# display r squared values for lm
Vsum <- summary(Vmodel)$r.squared
# Csum <- summary(Cmodel)$r.squared

# graph relationship
fig_C_N <- Full_data %>% 
  filter(CowTagID != "VSEEP") %>% 
  #select(Location, CowTagID, Silicate_umolL, C_N) %>% 
  ggplot(aes(x=Silicate_umolL,
             y = C_N,
             label = CowTagID
             #color = Location)
             ), color = "black") +
  geom_point() +
  geom_text_repel() +
  geom_smooth(method = "lm", color = "black") +
  labs(x = "Range of Silicate (umolL)",
       y = "Range of C:N Ratio",
       caption = paste("Varari R-squared:",round(Vsum, 2) #, "\n",
                       #"Cabral R-squared:", round(Csum, 2)
                       )) +
  #facet_wrap(~Location, scales = "free") +
  theme_bw() +
  theme(strip.background = element_rect(fill = "white"))

```


del15N ~ Silicate
```{r}
## del15N ~ Silicate
# linear model of del15N with respect to silicate
Vdata <- Full_data %>% 
  filter(CowTagID != "VSEEP")
Vmodel <- lm(data = Vdata, del15N ~ Silicate_umolL)
# Cdata <- Full_data %>%
#   filter(Location == "Cabral") %>% 
#   filter(CowTagID != "CSEEP")
# Cmodel <- lm(data = Cdata, del15N ~ Silicate_umolL)

# display r squared values for lm
Vsum <- summary(Vmodel)$r.squared
# Csum <- summary(Cmodel)$r.squared

# graph relationship
fig_del15N <- Full_data %>% 
  filter(CowTagID != "VSEEP") %>% 
  #select(Location, CowTagID, Silicate_umolL, del15N) %>% 
  ggplot(aes(x=Silicate_umolL,
             y = del15N,
             label = CowTagID
             #color = Location)
             ), color = "black") +
  geom_point() +
  geom_text_repel() +
  geom_smooth(method = "lm", color = "black") +
  labs(x = "Range of Silicate (umolL)",
       y = "Range of delta 15N Ratio",
       caption = paste("Varari R-squared:",round(Vsum, 2) #, "\n",
                       #"Cabral R-squared:", round(Csum, 2)
                       )) +
  #facet_wrap(~Location, scales = "free") +
  theme_bw() +
  theme(strip.background = element_rect(fill = "white"))

```

## Patch together above figures to save
```{r}
fig_TornataN <- fig_N_percent + fig_C_N + fig_del15N +
  plot_annotation(title = paste("Relationship of T. ornata tissue Nitrogen to Silicate"))

ggsave(here("Output","Tissue_N_Silicate_Figures.png"), fig_TornataN, height = 10, width = 16)
ggsave(here("Output","Tissue_N_Silicate_Figures.pdf"), fig_TornataN, height = 10, width = 16)

fig_TornataN

```


## Test for normality
```{r, message = F}

# get column names and total # cols
numbData <- Full_data %>% 
  select_at(vars(Salinity:N_percent))
numbNames <- colnames(numbData)

# create list to put plots into
q <- list()

# save hist for each variable
for(i in 1:ncol(numbData)){
  
# test for normality
norm <- shapiro.test(Full_data[[numbNames[i]]])
# norm[[2]] shows p-value
signif <- ifelse(norm[[2]] >= 0.05, "Normal", "Not Normal")

# plot histogram  
 p <- Full_data %>%
   ggplot(aes(x = Full_data[[numbNames[i]]])) + 
   geom_histogram() +
   labs(x = numbNames[i],
        title = paste0(numbNames[i],": ",signif),
        subtitle = paste("p =",norm[[2]], "(Shapiro Wilk Test)")) +
   theme_bw()
 
 # to save as single pdf:
 # Create Plot and save to list p
  q[[i]] <- p
}


# Save all plots in a single dated pdf
pdf(here("Output","SGDZones","histograms",paste0("Range_Histograms.pdf")), onefile = TRUE)
for (i in seq(length(q))) {
  tplot <- q[[i]]
  print(tplot)
}
dev.off()

```


## Transform and scale data

- ln transform left-skewed data
- square root transform right-skewed data
```{r, message= F}
Trans_data <- Full_data %>% 
  mutate_at(.vars = c('Salinity',
                      'TA',
                      'pH',
                      'Phosphate_umolL',
                      'Silicate_umolL',
                      'NN_umolL',
                      'Ammonia_umolL',
                    #  'M_C',
                    #  'HIX',
                      'VisibleHumidic_Like',
                    #  'Tryptophan_Like',
                    #  'Tyrosine_Like',
                      'del15N'),
                    #  'C_N',
                    #  'N_percent',

            .funs = ~log(.x + 0.01))  # ln transform for left-skewed

```


Test for normality
```{r, message = F}
# get column names and total # cols
numbData <- Trans_data %>% 
  select_at(vars(Salinity:N_percent))
numbNames <- colnames(numbData)

# create list to put plots into
q <- list()

# save hist for each variable
for(i in 1:ncol(numbData)){
  
# test for normality
norm <- shapiro.test(Trans_data[[numbNames[i]]])
# norm[[2]] shows p-value
signif <- ifelse(norm[[2]] >= 0.05, "Normal", "Not Normal")

# plot histogram  
 p <- Trans_data %>%
   ggplot(aes(x = Trans_data[[numbNames[i]]])) + 
   geom_histogram() +
   labs(x = numbNames[i],
        title = paste0("Transformed ",numbNames[i],": ",signif),
        subtitle = paste("p =",norm[[2]], "(Shapiro Wilk Test)")) +
   theme_bw()
 #ggsave(here("Output","SGDZones","histograms","meanValues",paste0("transformed_mean_",numbNames[i],"_hist.png")),p) # save in hist folder
 
 # to save as single pdf:
 # Create Plot and save to list p
  q[[i]] <- p
}

# Save all plots in a single dated pdf
pdf(here("Output","SGDZones","histograms",paste0("Transformed_Range_Histograms.pdf")), onefile = TRUE)
for (i in seq(length(q))) {
  tplot <- q[[i]]
  print(tplot)
}
dev.off()
  
```


Scale the data (and maybe center it?)
```{r}
## scale data
Scale_data <- Trans_data %>% 
  mutate_at(vars(Salinity:N_percent),
            .funs = ~scale(.x, center=T, scale=T))


```



## Prepare for Clustering

Taking from the VarSelLCM.R script

```{r}
V_data <-Scale_data %>% filter(Location == "Varari")
#C_data <-Scale_data %>% filter(Location == "Cabral")

## Force type data.frame
class(V_data) = "data.frame" 
#class(C_data) = "data.frame"

```



Indicate the number of cores you want to use for parallelization
```{r}
nb.CPU <- 4 # cores on my computer dedicated to the process (want to use ~ half)

```


## Clustering
This section performs a clustering analysis of the *biogeochemistry and* **Turbinaria ornata** *nutrient* data set. 

*Warning the univariate margin distribution are defined by class of the features: numeric columns imply Gaussian distributions, integer columns imply Poisson distribution while factor (or ordered) columns imply multinomial distribution*
```{r}
# Data loading:
# x contains the observed variables
# z the known status (i.e. 1: Plate and 2: Seep)


ztrue_V <- V_data[,'N_percent'] # compare clustering with del15N in turb
#ztrue_C <- C_data[,'N_percent']

x_V <- V_data %>% select(Salinity:N_percent) # only biogeochemical and turb nutrient data
#x_C <- C_data %>% select(Salinity:N_percent)

x_V <- x_V %>% 
  mutate_all(.funs = as.numeric)
  
#x_C <- x_C %>% 
#  mutate_all(.funs = as.numeric)

```


Clustering is performed with or without variable selection. 
Model selection is done with BIC because the number of observations is large (compared to the number of features).

```{r, comment=""}
set.seed(7) # set the seed to get the same one every time

# Cluster analysis without variable selection
res_without_V <- VarSelCluster(x_V, # matrix/data frame (only the numerical data for now) 
                             gvals = 3, # specify to use 3 clusters
                             #gvals = 1:ncol(x_V), # defines number of components (clusters) to consider
                             vbleSelec = FALSE, # indicates if a variable selection is done
                             crit.varsel = "BIC") # defines the info criterion used for model selection
# res_without_C <- VarSelCluster(x_C, 
#                              gvals = 3,
#                              #gvals = 1:ncol(x_C), 
#                              vbleSelec = FALSE, 
#                              crit.varsel = "BIC")


# Cluster analysis with variable selection (with parallelization)
res_with_V <- VarSelCluster(x_V, 
                          gvals = 3,
                          #gvals = 1:ncol(x_V), 
                          vbleSelec = TRUE, # indicates if a variable selection is done 
                          crit.varsel = "BIC")
# res_with_C <- VarSelCluster(x_C, 
#                           gvals = 3,
#                           #gvals = 1:ncol(x_C), 
#                           vbleSelec = TRUE,
#                           crit.varsel = "BIC")


```

Comparison of the BIC for both models: variable selection permits to improve the BIC
```{r, comment=""}
## Varari
BIC(res_without_V)
BIC(res_with_V) 

if(abs(BIC(res_without_V)) < abs(BIC(res_with_V))){ # choose lowest BIC
  res_V <- res_without_V} else {
  res_V <- res_with_V
  }

## Cabral
# BIC(res_without_C)
# BIC(res_with_C) 
# 
# if(abs(BIC(res_without_C)) < abs(BIC(res_with_C))){ # choose lowest BIC
#   res_C <- res_without_C} else {
#   res_C <- res_with_C
#   }
```


Evaluation of the partition accuracy: Adjusted Rand Index (ARI) is computed between the true partition (ztrue) and its estimators.
The expectation of ARI is zero if the two partitions are independent. 
The ARI is equal to one if the partitions are equals.
Variable selection permits to improve the ARI.
Note that ARI cannot be used for model selection in clustering, because there is no true partition.

Partition near 0 indicates that the clusters are very related to the factor we related the matrix to.
Can compare other factors in the future (ie. bacteria communities or coral counts, etc.)
```{r, comment=""}
## Varari
ARI(ztrue_V, fitted(res_V))
## Cabral
#ARI(ztrue_C, fitted(res_C))

```

To obtained the partition and the probabilities of classification
```{r, comment=""}
# Estimated partition - pulls out cluster enumerations in order of parameters
V_cluster<-fitted(res_V)
#C_cluster<-fitted(res_C)

# Estimated probabilities of classification
#head(fitted(res_V, type="probability"))
#head(fitted(res_C, type="probability"))
```

```{r, comment="", echo=F, eval=F}
## To get a summary of the selected model.

# Summary of the best model
#summary(V_cluster)
#summary(C_cluster)

summary(res_V) 
#summary(res_C) 
```


## Discriminative Power Barplots

Distribution of the most discriminative variable per clusters
```{r, comment=""}
# Barplots

Vdes<-plot(x = res_V, y = 1:ncol(x_V))
#Cdes<-plot(x = res_C, y = 1:ncol(x_C))

ggsave(here("Output","SGDZones","Varari",paste0("DiscPower_Varari_Range.png")),Vdes, height = 10, width = 10)
ggsave(here("Output","SGDZones","Varari",paste0("DiscPower_Varari_Range.pdf")),Vdes, height = 10, width = 10)
# ggsave(here("Output","SGDZones","Cabral",paste0("DiscPower_Cabral_Range.png")),Cdes, height = 10, width = 10)

```

## Empirical vs Theoretical distributions (quick check for good fit)

Example empirical and theoretical distributions of the most discriminative variable (to check that the distribution is well-fitted)
```{r, comment=""}
# Empirical and theoretical distributions (to check that the distribution is well-fitted)

plot(res_V, y="del15N", type="cdf")
plot(res_V, y="N_percent", type="cdf")
plot(res_V, y="C_N", type="cdf")
plot(res_V, y="Silicate_umolL", type="cdf")

```

Distribution of a categorical variable per clusters
(when we have categorical)
```{r, comment=""}
# Summary of categorical variable
# plot(res_with, y="Shore_Habitat")
```

To view details about the selected models
```{r, comment="", warning=FALSE}
# More detailed output
print(res_V)
#print(res_C)
```

To print the parameters
```{r, comment=""}
# Print model parameter
# coef(res_C)
# coef(res_V)
```


```{r, comment="", eval=F, echo=F}
## Probabilities of classification for new observations 
#(I don't know what this is)

# Probabilities of classification for new observations 
# predict(res_with, newdata = x[1:3,])
```



## Graph

Join site locations with respective cluster values
```{r}
# make cluster vector dataframe type to join to full_data
V_cluster<-as.data.frame(V_cluster)
#C_cluster<-as.data.frame(C_cluster)

# join cluster ID's to full_data
V_Cluster_data<-V_data %>% 
  cbind(V_cluster) %>% 
  # relabel cluster ID's
  mutate(V_cluster = ifelse(V_cluster == 1, "High", V_cluster)) %>% 
  mutate(V_cluster = ifelse(V_cluster == 2, "Low", V_cluster)) %>% 
  mutate(V_cluster = ifelse(V_cluster == 3, "Mid", V_cluster)) %>% 
  # as.factor and relevel cluster ID's
  mutate(V_cluster = as.factor(V_cluster)) %>% 
  mutate(V_cluster = fct_relevel(V_cluster, levels = c("High", "Mid", "Low")))
# C_Cluster_data<-C_data %>% 
#   cbind(C_cluster) %>% 
#   mutate(C_cluster = as.factor(C_cluster))


### Save clusters in csv
SaveTransScale <- V_Cluster_data %>% 
  mutate_at(vars(Salinity:N_percent), .funs = as.numeric)
write_csv(SaveTransScale, here("Data","Surveys","Cluster_metadata.csv"))

```  




### Create Base Maps for Varari and Cabral
```{r}

# mean lat and long for the maps
LocationGPS <- Full_data %>%
  group_by(Location) %>% # varari vs cabral
  summarise(lon = median(lon, na.rm = TRUE),
            lat = median(lat, na.rm = TRUE))

# CowTagIDGPS <- Full_data %>%
#   group_by(Location, CowTagID) %>%
#   summarise(lon = mean(lon, na.rm = TRUE),
#             lat = mean(lat, na.rm = TRUE))


# Varari
VarariBaseMap<-get_map(LocationGPS %>% filter(Location == "Varari") %>% select(lon,lat), maptype = 'satellite', zoom = 18)
# Cabral
# CabralBaseMap<-get_map(LocationGPS %>% filter(Location == "Cabral") %>% select(lon,lat), maptype = 'satellite', zoom = 18)
```

### Show basemaps
```{r}
# Moorea
MooreaMap<-get_map('Moorea', maptype = 'satellite', zoom = 12)

MooreaMapPlot <- ggmap(MooreaMap) + # base map
  
  geom_rect(data=LocationGPS, aes(xmin=lon[1] - 0.006, xmax=lon[1] + 0.006, ymin=lat[1] - 0.01, ymax=lat[1] + 0.01), color="white", alpha=0, size = 2) + # Cabral square
  
  geom_rect(data=LocationGPS, aes(xmin=lon[2] - 0.006, xmax=lon[2] + 0.006, ymin=lat[2] - 0.01, ymax=lat[2] + 0.01), color="white", alpha=0, size = 2) + # Varari square
  
  geom_point(data=LocationGPS, aes(x = lon, y = lat, label = Location), 
             shape = 18, color = "white", fill = "white", size = 8) + # adds symbol at center of Location
  
  labs(x = "Longitude", y = "Latitude") +
  
  geom_text(data = LocationGPS, aes(label = Location), color = "white", hjust = -1, size = 10) + # adds Location names to the right of the boxes
  
  geom_segment(x = LocationGPS$lon[1] + 0.006, y = LocationGPS$lat[1], xend = LocationGPS$lon[1] + 0.023, yend = LocationGPS$lat[1], color = "white", size = 2) + # adds horizontal line from edge of box to Location name
  
  geom_segment(x = LocationGPS$lon[2] + 0.006, y = LocationGPS$lat[2], xend = LocationGPS$lon[2] + 0.023, yend = LocationGPS$lat[2], color = "white", size = 2)

MooreaMapPlot

#ggsave(here("Output","Moorea_Map.png"),MooreaMapPlot,height = 10, width = 10)
```

```{r}
# Varari
VmapSites <- ggmap(VarariBaseMap) +
  geom_point(data = Full_data,
             aes(x = lon, y = lat),
             color = "white",
             size = 2) + 
  labs(x = "Longitude", y = "Latitude",  #label x and y axes
        title = "Varari Sample Locations") +
  geom_label(data = Full_data,
             aes(x = lon, y = lat,
                 label = CowTagID),
             size = 2, alpha = 0.8)

VmapSites
ggsave(here("Output","SGDZones","Varari","Varari_CowTagID_Map.png"),VmapSites,height = 10, width = 10)
ggsave(here("Output","SGDZones","Varari","Varari_CowTagID_Map.pdf"),VmapSites,height = 10, width = 10)

# cabral
# CmapSites <- ggmap(CabralBaseMap) +
#   geom_point(data = Full_data,
#              aes(x = lon, y = lat),
#              color = "white",
#              size = 2) + 
#   labs(x = "Longitude", y = "Latitude",  #label x and y axes
#         title = "Cabral Sample Locations") +
#   geom_label(data = Full_data,
#              aes(x = lon, y = lat,
#                  label = CowTagID),
#              size = 2, alpha = 0.2)
# 
# CmapSites
#ggsave(here("Output","SGDZones","Cabral","Cabral_CowTagID_Map.png"),CmapSites,height = 10, width = 10)
```


## Show clusters on maps
```{r}

## create palette
V_cluster_palette <- c("brown3", "white", "#fad02c") #1 is dark yellow #2 is baby blue #3 is red 

### Map Varari clusters

# isolate Varari seep
VSeepPt <- V_Cluster_data %>% filter(CowTagID == "VSEEP") 
VSeepPtID <- VSeepPt %>% 
  select(V_cluster)
VSeepPtID <- as.factor(VSeepPtID[1,1])
  

cluster_varari_map <- ggmap(VarariBaseMap) +
  geom_point(data = V_Cluster_data,
             aes(x = lon, y = lat,
                 fill = V_cluster),
             shape = 21,
             color = "black",
             size = 3) + # set alpha and color aesthetics
  geom_point(data = VSeepPt, # star the seepage point
             aes(x = lon, y = lat),
             shape = 24,
             fill = as.character(V_cluster_palette[VSeepPtID]), # selects the palette color corresponding to the associated cluster number
             color = "black",
             size = 4) +
  # scale_color_manual(values = pnw_palette("Moth", 4)) +
  labs(x = "Longitude", y = "Latitude",  #label x and y axes
        title = "Varari Clusters (LCM)",
       subtitle = "Transformed and Scaled Parameter Ranges",
       fill = "Relative SGD Influence") +
  scale_fill_manual(values = V_cluster_palette)

cluster_varari_map

ggsave(here("Output","SGDZones","Varari",paste0("Varari_Cluster_Map_Range.png")),cluster_varari_map,height = 10, width = 10)
ggsave(here("Output","SGDZones","Varari",paste0("Varari_Cluster_Map_Range.pdf")),cluster_varari_map,height = 10, width = 10)

```

```{r, eval = F, echo = F}
### IGNORNING FOR NOW

## create palette
C_cluster_palette <- c("#fad02c", "limegreen", "white", "brown3") # seep is red

### Map Cabral clusters
CSeepPt <- C_Cluster_data %>% filter(CowTagID == "CSEEP") # isolate Varari seep
CSeepPtID<-CSeepPt %>% 
  select(C_cluster) %>% 
  as.numeric()

cluster_cabral_map <- ggmap(CabralBaseMap) +
  geom_point(data = C_Cluster_data,
             aes(x = lon, y = lat,
                 fill = C_cluster),
             shape = 22,
             color = "black",
            size = 3) + # set alpha and color aesthetics
    geom_point(data = CSeepPt, # star the seepage point
             aes(x = lon, y = lat),
             shape = 25,
             fill = as.character(C_cluster_palette[CSeepPtID]), # selects the palette color corresponding to the associated cluster number
             color = "black",
             size = 4) +
  # scale_color_manual(values = pnw_palette("Moth", 4)) +
  labs(x = "Longitude", y = "Latitude",  #label x and y axes
      title = "Cabral, Clusters (LCM) \n Transformed and Scaled",
       subtitle = "Parameter Range",
       color = "Cabral Clusters") +
  scale_fill_manual(values = C_cluster_palette)

cluster_cabral_map

#ggsave(here("Output","SGDZones","Cabral",paste0("Cabral_Cluster_Map_RangeTransScale.png")),cluster_cabral_map,height = 10, width = 10)


```

*Triangles showing seepage points*


```{r, eval = F, echo = F}
######### Save maps together (IGNORING FOR NOW)

  ### Map Varari clusters
cluster_varari_map_noLab <- ggmap(VarariBaseMap) +
  geom_point(data = V_Cluster_data,aes(x = lon, y = lat,fill = V_cluster),
             shape = 21,color = "black",size = 4) + 
  geom_point(data = VSeepPt, # star the seepage point
             aes(x = lon, y = lat),
             shape = 24,
             fill = "brown3",
             color = "black",
             size = 4) +
  # scale_color_manual(values = pnw_palette("Moth", 4)) +
  labs(x = "Longitude", y = "Latitude", fill = "Varari Clusters") +
  scale_fill_manual(values = V_cluster_palette) +
  labs(title = "Varari")
  
### Map Cabral clusters
cluster_cabral_map_noLab <- ggmap(CabralBaseMap) +
  geom_point(data = C_Cluster_data,aes(x = lon, y = lat,fill = C_cluster),
             shape = 22,color = "black",size = 4) + 
  geom_point(data = CSeepPt, # star the seepage point
             aes(x = lon, y = lat),
             shape = 25,
             fill = "brown3",
             color = "black",
             size = 4) +
  # scale_color_manual(values = pnw_palette("Moth", 4)) +
  labs(x = "Longitude", y = "Latitude", fill = "Cabral Clusters") +
  scale_fill_manual(values = C_cluster_palette) +
  labs(title = "Cabral")



ClusterMaps<-cluster_varari_map_noLab + cluster_cabral_map_noLab + 
  plot_layout(nrow = 1,
              guides = "collect") + # put both legends in same area of plot
  patchwork::plot_annotation(tag_levels = 'A',
                             theme = theme(plot.title = element_text(size = rel(1.5), 
                                                                     face = "bold", 
                                                                     hjust = 0.5, 
                                                                     margin = margin(t = 10, b = 20,
                                                                                     unit = "pt"))))
ClusterMaps

#ggsave(plot = ClusterMaps, filename = here("Output","SGDZones","Cluster_Maps_Range.png"), width = 14, height = 10)
```


## Boxplots showing driving factors
```{r}

### Create boxplot faceted by clusters
#First, pivot longer
V_cluster_long <- V_Cluster_data %>%
  pivot_longer(cols = c(Salinity:N_percent),
               names_to = "Nutrient_parameters",
               values_to = "Nutrient_values")

Vbox<-ggplot(V_cluster_long, 
              mapping = aes(x = reorder_within(Nutrient_parameters,desc(Nutrient_values), V_cluster, sep = ": "), # tidytext::reorder_within allows reordering while using facet_wrap if scales = 'free_x'
                            y= Nutrient_values, 
                            color = V_cluster)) +
  geom_boxplot(fill = "azure4")+
  facet_wrap(~V_cluster, scales = "free_x", nrow = 1) +
  ylab("Concentration") +
  xlab("") +
  labs(color = "Varari Clusters") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, vjust = -.1),
        panel.background = element_rect(fill = "azure4"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        strip.background = element_blank()) +
  scale_color_manual(values = V_cluster_palette)

# C_cluster_long <- C_Cluster_data %>%
#   pivot_longer(cols = c(Salinity:N_percent),
#                names_to = "Nutrient_parameters",
#                values_to = "Nutrient_values")
# 
# Cbox<-ggplot(C_cluster_long, 
#               mapping = aes(x = reorder_within(Nutrient_parameters,desc(Nutrient_values), C_cluster, sep = ": "),
#                             y= Nutrient_values, 
#                             color = C_cluster)) +
#   geom_boxplot(fill = "azure4")+
#   facet_wrap(~C_cluster, scales = "free_x", nrow = 1) +
#   ylab("Concentration") +
#   xlab("") +
#   labs(color = "Cabral Clusters") +
#   theme_bw() +
#   theme(axis.text.x = element_text(angle = 90, vjust = -.1),
#         panel.background = element_rect(fill = "azure4"),
#         panel.grid.major = element_blank(),
#         panel.grid.minor = element_blank(),
#         strip.background = element_blank()) +
#   scale_color_manual(values = C_cluster_palette)

Vbox
#Cbox

ggsave(here("Output","SGDZones","Varari",paste0("Boxplots_Varari_Range.png")), Vbox, height = 20, width = 8)
ggsave(here("Output","SGDZones","Varari",paste0("Boxplots_Varari_Range.pdf")), Vbox, height = 20, width = 8)

#ggsave(here("Output","SGDZones","Cabral",paste0("Boxplots_Cabral_RangeTransScale.png")), Cbox, height = 20, width = 8)
```

```{r, eval = F, echo = F}
### patch clusters together
ClusterBoxPlots<-Vbox + Cbox + 
  plot_layout(nrow = 2,
              guides = "collect") + # put both legends in same area of plot
  patchwork::plot_annotation(tag_levels = 'A',
                             theme = theme(plot.title = element_text(size = rel(1.5), 
                                                                     face = "bold", 
                                                                     hjust = 0.5, 
                                                                     margin = margin(t = 10, b = 20,
                                                                                     unit = "pt"))))
ClusterBoxPlots

#ggsave(plot = ClusterBoxPlots, filename = here("Output","SGDZones","Cluster_BoxPlots_Range.png"), width = 10, height = 14)

```



## PCA for clustering
```{r}
# V_Cluster_data
# C_Cluster_data

# extract parameters for the PCA
V_pca_data <-V_Cluster_data %>% 
  filter(CowTagID !="VSEEP") %>% 
  select(-(Location:lon),-V_cluster)

# C_pca_data <-C_Cluster_data %>% 
#   filter(CowTagID !="CSEEP") %>% 
#   select(-(Location:lon),-C_cluster)

# Run the PCA
pca_V <- prcomp(V_pca_data) # , scale. = TRUE, center = TRUE) # data is alraedy scaled and centered
#pca_C <- prcomp(C_pca_data)

# Extract the scores and loadings
PC_scores_V <-as_tibble(pca_V$x[,1:2])
PC_loadings_V<-as_tibble(pca_V$rotation) %>%
  bind_cols(labels = rownames(pca_V$rotation))

# PC_scores_C <-as_tibble(pca_C$x[,1:2])
# PC_loadings_C<-as_tibble(pca_C$rotation) %>%
#   bind_cols(labels = rownames(pca_C$rotation))

# Put it with all the original data
V_pca_data_all<-V_Cluster_data %>%
  filter(CowTagID !="VSEEP") %>% 
  bind_cols(PC_scores_V)

# C_pca_data_all<-C_Cluster_data %>%
#   filter(CowTagID !="CSEEP") %>% 
#   bind_cols(PC_scores_C)
```

## scores plot
```{r}
p1_V<-V_pca_data_all %>%
  ggplot(aes(x = PC1, 
             y = PC2, 
             fill = V_cluster))+
  geom_point(shape = 21,
             color = "white",
             size = 3) +
  coord_cartesian(xlim = c(-4, 7), ylim = c(-6, 4)) +
  #scale_shape_manual(values = c(22,16))+
  scale_colour_hue(l = 45)+ # l: luminance/lightness 0-100
  scale_fill_hue(l = 45)+ 
  scale_fill_manual(values = V_cluster_palette) +
  ggforce::geom_mark_ellipse(
    aes(fill = V_cluster, label = V_cluster), 
    alpha = .15, show.legend = FALSE,  label.buffer = unit(1, "mm"))+
  theme_bw()+
  theme(legend.position = "none", panel.background = element_rect(fill = "azure4"),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  labs(title = "Varari Scores Plot")

# p1_C<-C_pca_data_all %>%
#   ggplot(aes(x = PC1, 
#              y = PC2, 
#              fill = C_cluster))+
#   geom_point(shape = 21,
#              color = "white",
#              size = 3) +
#   coord_cartesian(xlim = c(-4, 7), ylim = c(-6, 4)) +
#   #scale_shape_manual(values = c(22,16))+
#   scale_colour_hue(l = 45)+ # l: luminance/lightness 0-100
#   scale_fill_hue(l = 45)+ 
#   scale_fill_manual(values = C_cluster_palette) +
#   ggforce::geom_mark_ellipse(
#     aes(fill = C_cluster, label = C_cluster), 
#     alpha = .15, show.legend = FALSE,  label.buffer = unit(1, "mm"))+
#   theme_bw()+
#   theme(legend.position = "none", panel.background = element_rect(fill = "azure4"),
#         panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
#   labs(title = "Cabral Scores Plot")
# 
# p1_V / p1_C # patchwork plot

```

## loadings plot
```{r}
# loadings plot 
p2_V<-PC_loadings_V %>%
  ggplot(aes(x=PC1, y=PC1, label=labels))+ # labels are the parameters
    geom_segment(aes(x=0,y=0,xend=PC1*10,yend=PC2*10),
      arrow=arrow(length=unit(0.1,"cm")), color = "grey")+
  annotate("text", x = PC_loadings_V$PC1*10+0.1, y = PC_loadings_V$PC2*10+.1,
           label = PC_loadings_V$labels)+
  coord_cartesian(xlim = c(-8, 3), ylim = c(-7, 5)) +
   theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  labs(title = "Varari Loadings")

# p2_C<-PC_loadings_C %>%
#   ggplot(aes(x=PC1, y=PC1, label=labels))+ # labels are the parameters
#     geom_segment(aes(x=0,y=0,xend=PC1*10,yend=PC2*10),
#       arrow=arrow(length=unit(0.1,"cm")), color = "grey")+
#   annotate("text", x = PC_loadings_C$PC1*10+0.1, y = PC_loadings_C$PC2*10+.1,
#            label = PC_loadings_C$labels)+
#   coord_cartesian(xlim = c(-8, 4), ylim = c(-7, 5)) +
#    theme_bw()+
#   theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank())+
#   labs(title = "Cabral Loadings")
```

```{r}
### Patch PCA plots
VarariPCA<-p1_V+p2_V+ 
  patchwork::plot_annotation("Varari Clusters", 
                             theme = theme(plot.title = element_text(size = rel(1.5), 
                                                                     face = "bold", 
                                                                     hjust = 0.5, 
                                                                     margin = margin(t = 10, b = 20,
                                                                                     unit = "pt"))))
# CabralPCA<-p1_C+p2_C+ 
#   patchwork::plot_annotation("Cabral Clusters", 
#                              theme = theme(plot.title = element_text(size = rel(1.5), 
#                                                                      face = "bold", 
#                                                                      hjust = 0.5, 
#                                                                      margin = margin(t = 10, b = 20,
#                                                                                      unit = "pt"))))

ggsave(plot = VarariPCA, filename = here("Output","SGDZones","Varari","VarariPCA_Range.pdf"), width = 14, height = 6)
#ggsave(plot = CabralPCA, filename = here("Output","SGDZones","Cabral","CabralPCA_Range.pdf"), width = 14, height = 6)

VarariPCA

```




# Turbinaria ornata clustering

## Run clusters again only using _Turbinaria ornata_ data to check clusters against full biogeochemical swath

```{r}
## Use Scale_data and remove all but turb data

Turb_cluster_data <- Scale_data %>% 
  select(Location, CowTagID, lat, lon, del15N, C_N, N_percent)

```



```{r}
V_data_turb <-Turb_cluster_data %>% filter(Location == "Varari")
#C_data_turb <-Turb_cluster_data %>% filter(Location == "Cabral")


## Force type data.frame
class(V_data_turb) = "data.frame" 
#class(C_data_turb) = "data.frame"

```



## Clustering
This section performs a clustering analysis of the *biogeochemistry and* **Turbinaria ornata** *nutrient* data set. 

*Warning the univariate margin distribution are defined by class of the features: numeric columns imply Gaussian distributions, integer columns imply Poisson distribution while factor (or ordered) columns imply multinomial distribution*
```{r}
# Data loading:
# x contains the observed variables
# z the known status (i.e. 1: Plate and 2: Seep)



x_V_turb <- V_data_turb[,5:ncol(V_data_turb)] # only turbinaria data
#x_C_turb <- C_data_turb[,5:ncol(C_data_turb)]

x_V_turb <- x_V_turb %>% 
  mutate_all(.funs = as.numeric)
  
# x_C_turb <- x_C_turb %>% 
#   mutate_all(.funs = as.numeric)

```


Clustering is performed with or without variable selection. 
Model selection is done with BIC because the number of observations is large (compared to the number of features).

```{r, comment=""}
# Cluster analysis without variable selection
res_without_V_turb <- VarSelCluster(x_V_turb, # matrix/data frame (only the numerical data for now) 
                             gvals = 1:ncol(x_V_turb), # defines number of components (clusters) to consider
                             vbleSelec = FALSE, # indicates if a variable selection is done
                             crit.varsel = "BIC") # defines the info criterion used for model selection
# res_without_C_turb <- VarSelCluster(x_C_turb, 
#                              gvals = 1:ncol(x_C_turb), 
#                              vbleSelec = FALSE, 
#                              crit.varsel = "BIC")


# Cluster analysis with variable selection (with parallelization)
res_with_V_turb <- VarSelCluster(x_V_turb, 
                          gvals = 1:ncol(x_V_turb), 
                          vbleSelec = TRUE, # indicates if a variable selection is done 
                          crit.varsel = "BIC")
# res_with_C_turb <- VarSelCluster(x_C_turb, 
#                           gvals = 1:ncol(x_C_turb), 
#                           vbleSelec = TRUE,
#                           crit.varsel = "BIC")


```

Comparison of the BIC for both models: variable selection permits to improve the BIC
```{r, comment=""}
## Varari
BIC(res_without_V_turb)
BIC(res_with_V_turb) 

if(abs(BIC(res_without_V_turb)) < abs(BIC(res_with_V_turb))){ # choose lowest BIC
  res_V_turb <- res_without_V_turb} else {
  res_V_turb <- res_with_V_turb
  }

## Cabral
# BIC(res_without_C_turb)
# BIC(res_with_C_turb) 
# 
# if(abs(BIC(res_without_C_turb)) < abs(BIC(res_with_C_turb))){ # choose lowest BIC
#   res_C_turb <- res_without_C_turb} else {
#   res_C_turb <- res_with_C_turb
#   }
```



To obtained the partition and the probabilities of classification
```{r, comment=""}
# Estimated partition - pulls out cluster enumerations in order of parameters
V_cluster_turb<-fitted(res_V_turb)
#C_cluster_turb<-fitted(res_C_turb)

V_cluster_turb
#C_cluster_turb

# Estimated probabilities of classification
#head(fitted(res_V, type="probability"))
#head(fitted(res_C, type="probability"))
```


## Discriminative Power Barplots

Distribution of the most discriminative variable per clusters
```{r, comment=""}
# Barplots

Vdes_turb<-plot(x = res_V_turb, y = 1:ncol(x_V_turb))
#Cdes_turb<-plot(x = res_C_turb, y = 1:ncol(x_C_turb))

ggsave(here("Output","SGDZones","Varari","DiscPower_TurbRange_Varari.png"),Vdes_turb, height = 10, width = 10)
ggsave(here("Output","SGDZones","Varari","DiscPower_TurbRange_Varari.pdf"),Vdes_turb, height = 10, width = 10)
#ggsave(here(paste0("Output","DiscPower_TurbRange_Cabral.png")),Cdes_turb, height = 10, width = 10)

```

## Empirical vs Theoretical distributions (quick check for good fit)

Example empirical and theoretical distributions of the most discriminative variable (to check that the distribution is well-fitted)
```{r, comment=""}
# Empirical and theoretical distributions (to check that the distribution is well-fitted)

plot(res_V_turb, y="N_percent", type="cdf")
plot(res_V_turb, y="del15N", type="cdf")
plot(res_V_turb, y="C_N", type="cdf")

```


## Graph

Add site locations to cluster value df
```{r}
# make cluster vector dataframe type to join to full_data
V_cluster_turb<-as.data.frame(V_cluster_turb)
#C_cluster_turb<-as.data.frame(C_cluster_turb)

# join cluster ID's to full_data
V_Cluster_data_turb<-V_data_turb %>% 
  cbind(V_cluster_turb) %>% 
  # relabel cluster ID's
  mutate(V_cluster_turb = ifelse(V_cluster_turb == 1, "Mid", V_cluster_turb)) %>% 
  mutate(V_cluster_turb = ifelse(V_cluster_turb == 2, "Low", V_cluster_turb)) %>% 
  mutate(V_cluster_turb = ifelse(V_cluster_turb == 3, "High", V_cluster_turb)) %>% 
  # as.factor and relevel cluster ID's
  mutate(V_cluster_turb = as.factor(V_cluster_turb)) %>% 
  mutate(V_cluster_turb = fct_relevel(V_cluster_turb, levels = c("High", "Mid", "Low")))



# C_Cluster_data_turb<-C_data_turb %>% 
#   cbind(C_cluster_turb) %>% 
#   mutate(C_cluster_turb = as.factor(C_cluster_turb))

### Save clusters in csv
SaveTransScale_turb <- V_Cluster_data_turb %>% 
  mutate_at(vars(del15N:N_percent), .funs = as.numeric)
write_csv(SaveTransScale_turb, here("Data","Surveys","Cluster_turb_metadata.csv"))

```  



## Show clusters on maps
```{r}

## create palette
V_cluster_palette_turb <- c("brown3", "white", "#fad02c") #3 is dark yellow #2 is baby blue #1 is red 

### Isolate seep data for point on map
VSeepPt_turb <- V_Cluster_data_turb %>% filter(CowTagID == "VSEEP") 
VSeepPtID_turb <- VSeepPt_turb %>% 
  select(V_cluster_turb)
VSeepPtID_turb <- as.factor(VSeepPtID_turb[1,1])

### Map Varari clusters
cluster_varari_map_turb <- ggmap(VarariBaseMap) +
  geom_point(data = V_Cluster_data_turb,
             aes(x = lon, y = lat,
                 fill = V_cluster_turb),
             color = "black",
             shape = 22,
             size = 3) + # set alpha and color aesthetics
  geom_point(data = VSeepPt_turb, # star the seepage point
             aes(x = lon, y = lat),
             shape = 25,
             size = 4,
             fill = as.character(V_cluster_palette_turb[VSeepPtID_turb])) +
  labs(x = "Longitude", y = "Latitude",  #label x and y axes
        title = "Varari T. ornata Clusters (LCM) \n Transformed and Scaled",
       subtitle = "Parameter Range",
       fill = "Relative SGD Influence") +
  scale_fill_manual(values = V_cluster_palette_turb)
    
cluster_varari_map_turb


ggsave(here("Output","SGDZones","Varari","Varari_Turb_Cluster_Map_Range.png"),cluster_varari_map_turb,height = 10, width = 10)
ggsave(here("Output","SGDZones","Varari","Varari_Turb_Cluster_Map_Range.pdf"),cluster_varari_map_turb,height = 10, width = 10)

# compare
cluster_varari_map

```


```{r, eval = F, echo = F}

  ### Map Cabral clusters
cluster_cabral_map_turb <- ggmap(CabralBaseMap) +
  geom_point(data = C_Cluster_data_turb,
             aes(x = lon, y = lat,
                 color = C_cluster_turb),
            size = 3) + # set alpha and color aesthetics
  # scale_color_manual(values = pnw_palette("Moth", 4)) +
  labs(x = "Longitude", y = "Latitude",  #label x and y axes
      title = "Cabral, T. ornata Clusters (LCM) \n Transformed and Scaled",
       subtitle = "Parameter Range",
       color = "Cabral Clusters")

#ggsave(here("Output","SGDZones","Cabral",paste0("Cabral_Turb_Cluster_Map_RangeTransScale.png")),cluster_cabral_map_turb,height = 10, width = 10)

cluster_cabral_map_turb
# compare
cluster_cabral_map

```



## Boxplots showing driving factors
```{r}

### Create boxplot faceted by clusters
#First, pivot longer
V_cluster_long_turb <- V_Cluster_data_turb %>%
  pivot_longer(cols = c(del15N:N_percent),
               names_to = "Nutrient_parameters",
               values_to = "Nutrient_values")

Vbox_turb<-ggplot(V_cluster_long_turb, 
                  aes(x = reorder_within(Nutrient_parameters, desc(Nutrient_values), V_cluster_turb), # tidytext::reorder_within allows reordering while using facet_wrap if scales = 'free_x'
                      y= Nutrient_values, 
                      color = V_cluster_turb)) +
  geom_boxplot(fill = "azure4")+
  facet_wrap(~V_cluster_turb, scales = "free_x") +
  ylab("Concentration") +
  xlab("") +
  labs(color = "Varari Clusters") +
  theme(axis.text.x = element_text(angle = 90, vjust = -.1),
        panel.background = element_rect(fill = "azure4"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  scale_color_manual(values = V_cluster_palette_turb)
  
Vbox_turb

# C_cluster_long_turb <- C_Cluster_data_turb %>%
#   pivot_longer(cols = c(del15N:N_percent),
#                names_to = "Nutrient_parameters",
#                values_to = "Nutrient_values")
# 
# Cbox_turb<-ggplot(C_cluster_long_turb, 
#               mapping = aes(x = reorder_within(Nutrient_parameters,desc(Nutrient_values), C_cluster_turb),
#                             y= Nutrient_values, 
#                             color = C_cluster_turb)) +
#   geom_boxplot()+
#   facet_wrap(~C_cluster_turb, scales = "free_x") +
#   ylab("Concentration") +
#   xlab("") +
#   labs(color = "Cabral Clusters") +
#   theme(axis.text.x = element_text(angle = 90, vjust = -.1))


ggsave(here("Output","SGDZones","Varari","Boxplots_Turb_Varari_Range.png"), Vbox_turb, height = 20, width = 8)
ggsave(here("Output","SGDZones","Varari","Boxplots_Turb_Varari_Range.pdf"), Vbox_turb, height = 20, width = 8)
#ggsave(here("Output","SGDZones","Cabral",paste0("Boxplots_Turb_Cabral_RangeTransScale.png")), Cbox_turb, height = 20, width = 8)

#Cbox_turb

```

