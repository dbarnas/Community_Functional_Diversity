---
title: "SGD Clustering"
author: "Danielle Barnas"
date: "2/6/2022"
output: html_document
---

### Clustering Analysis



Load Libraries
```{r, warning=FALSE, results='hide', message=FALSE}

#options('repos' = c(options('repos')$repos, RSPM = "https://my-repo.com/all/latest"))

library(tidyverse)
library(VarSelLCM) # LCM
library(ggmap)
library(ggridges)
library(PNWColors)
library(here)
library(curl)
 
API<-names(read_table(here("Data","API.txt")))
register_google(key = API) ### uses my API in separate txt file

set.seed(7) # set the seed to get the same one every time
```

Read in Data
```{r, warning = FALSE}
## Read in data

AllChemData<-read_csv(curl('https://raw.githubusercontent.com/njsilbiger/MooreaSGD_site-selection/main/Data/August2021/Allbiogeochemdata_QC.csv'))

turb<-read_csv(here("Data","Biogeochem","Turb_NC.csv"))
```


Clean Data for analysis
```{r, warning=FALSE}
## remove unnecessary/redundant turbinaria data to not include in cluster analysis
turb <- turb %>% 
  select(CowTagID, del15N, N_percent)


## Filter out unnecessary/redundant data
ReducedChemData <- AllChemData %>% 
  unite(Date,Tide,Day_Night, col = date_tide_day, sep = "_", remove = F) %>% 
  filter(date_tide_day != '2021-08-06_Low_Day') %>%  # remove redundant sampling. this was a very high 'low tide' so only use 2022-08-08 samples
  # only keep Plate and Seep data
  filter(Plate_Seep == "Plate" | Plate_Seep == "Seep") %>%  # ignores springs and well
  # remove unnecessary columns
  select(-c(Date,
            Time,
            DateTime, 
            date_tide_day, 
            Top_Plate_ID,
            Bottom_Plate_ID, 
            Jamie_Plate_ID,
            Temperature)) 
```

Histograms

- do ggridges or histogram to see distribution and log whatever isn't normal
- ggridges shows distribution of means vs raw data if I input the means (but raw data can help determine if I should use means or medians or max's etc.)
- summarise, log10 what needs it, then standardize and center, then select important variables
```{r, warning=F, message = F}
# add turb data for histograms
Full_data <- ReducedChemData %>% 
  full_join(turb, by = 'CowTagID')

# get column names and total # cols
numbData <- Full_data %>% 
  select_at(vars(Salinity:N_percent))
numbNames <- colnames(numbData)

# save hist for each variable
for(i in 1:ncol(numbData)){
  
# test for normality
norm <- shapiro.test(Full_data[[numbNames[i]]])
# norm[[2]] shows p-value
signif <- ifelse(norm[[2]] >= 0.05, "Normal", "Not Normal")

# plot histogram  
 p <- Full_data %>%
   ggplot(aes(x = Full_data[[numbNames[i]]])) + 
   geom_histogram() +
   labs(x = numbNames[i],
        title = paste0("Raw ",numbNames[i],": ",signif),
        subtitle = paste("p =",norm[[2]], "(Shapiro Wilk Test)")) +
   theme_bw()
 #ggsave(here("Output","SGDZones","histograms",paste0("raw_",numbNames[i],"_hist.png")),p) # save in hist folder
}

```

Transform not normal data

- log10 transform left-skewed data (not exponential)
- ln transform left-skewed data (exponential)
- square root transform right-skewed data
```{r, warning=F, message= F}
Trans_data <- Full_data %>% 
  mutate_at(.vars = c('Silicate_umolL',
                      'NN_umolL',
                      'Phosphate_umolL',
                      'Tryptophan_Like'),
            .funs = ~log(.x + 0.01)) %>%  # ln transform for exponential left-skewed
  mutate_at(.vars = c('TA',
                      'Ammonia_umolL',
                      'del15N',
                      'N_percent',
                      'HIX',
                      'Lignin_Like',
                      'M_C',
                      'MarineHumic_Like',
                      'Tyrosine_Like',
                      'VisibleHumidic_Like'),
            .funs = ~log10(.x + 0.01)) %>%  # log base 10 transform for left-skewed
  mutate_at(.vars = c('pH'),
            .funs = ~sqrt(.x + 0.01))


# get column names and total # cols
numbData <- Trans_data %>% 
  select_at(vars(Salinity:N_percent))
numbNames <- colnames(numbData)

# save hist for each variable
for(i in 1:ncol(numbData)){
  
# test for normality
norm <- shapiro.test(Trans_data[[numbNames[i]]])
# norm[[2]] shows p-value
signif <- ifelse(norm[[2]] >= 0.05, "Normal", "Not Normal")

# plot histogram  
 p <- Trans_data %>%
   ggplot(aes(x = Trans_data[[numbNames[i]]])) + 
   geom_histogram() +
   labs(x = numbNames[i],
        title = paste0("Transformed ",numbNames[i],": ",signif),
        subtitle = paste("p =",norm[[2]], "(Shapiro Wilk Test)")) +
   theme_bw()
 #ggsave(here("Output","SGDZones","histograms",paste0("transformed_",numbNames[i],"_hist.png")),p) # save in hist folder
}
  
```


Scale the data
```{r, warning = FALSE}
## scale data
Scale_data <- Trans_data %>% 
  mutate_at(vars(Salinity:N_percent),
            .funs = ~scale(.x, center=T, scale=T))


```



```{r}
## Summarise data
Scale_turb <- Scale_data %>% 
  select(CowTagID, del15N, N_percent)

Scale_data <- Scale_data %>% 
  select(-c(del15N,N_percent)) %>% 
  group_by(Location, CowTagID, lat, lon) %>%
  summarise_at(vars(Salinity:Lignin_Like), .funs = mean, na.rm=T) %>%  # get mean across sampling periods by site and plate
  full_join(Scale_turb, by = 'CowTagID')

head(Scale_data)
```  


Select only variables believed to be SGD influences
```{r, eval = F}

# Full_data <- Full_data %>% 
#   select(-c(
#     pH
#   ))

```



Separate data for Varari and Cabral locations
```{r}
V_data <-Scale_data %>% filter(Location == "Varari")
C_data <-Scale_data %>% filter(Location == "Cabral")

## Force type data.frame
class(V_data) = "data.frame" 
class(C_data) = "data.frame"

```







- Clustering is done with and without variable selection. Here ICL and MICL criteria are used because the number of observations is less than the number of features (thus, BIC is not relevant).
```{r, warning = FALSE}
### Taking from the VarSelLCM.R script

# Please indicate the number of cores you want to use for parallelization
nb.CPU <- 4 # cores on my computer dedicated to the process (want to use like half)


```

# Mixed-type data analysis
## Clustering
This section performs a clustering analysis of the *biogeochemistry and turbinaria nutrient* data set. 

*Warning the univariate margin distribution are defined by class of the features: numeric columns imply Gaussian distributions, integer columns imply Poisson distribution while factor (or ordered) columns imply multinomial distribution*
```{r, warning = FALSE}

# Data loading:
# x contains the observed variables
# z the known status (i.e. 1: Plate and 2: Seep)


ztrue_V <- V_data[,'CowTagID'] # compare clustering with plate
ztrue_C <- C_data[,'CowTagID']
x_V <- V_data[,5:ncol(V_data)] # all biogeochemical and turb nutrient data
x_C <- C_data[,5:ncol(V_data)]

x_V <- x_V %>% 
  mutate_all(.funs = as.numeric)
  
x_C <- x_C %>% 
  mutate_all(.funs = as.numeric)

```


Clustering is performed with variable selection. 
Model selection is done with BIC because the number of observations is large (compared to the number of features).
The number of components is between 1 and 3.
Do not hesitate to use parallelization (here only four cores are used).

```{r, comment="", warning=FALSE}
# Cluster analysis without variable selection
res_without_V <- VarSelCluster(x_V, # matrix/data frame (only the numerical data for now) 
                             gvals = 1:ncol(x_V), # defines number of components (clusters) to consider
                             vbleSelec = FALSE, # indicates if a variable selection is done
                             crit.varsel = "BIC") # defines the info criterion used for model selection
res_without_C <- VarSelCluster(x_C, 
                             gvals = 1:ncol(x_C), 
                             vbleSelec = FALSE, 
                             crit.varsel = "BIC")


# Cluster analysis with variable selection (with parallelization)
res_with_V <- VarSelCluster(x_V, 
                          gvals = 1:ncol(x_V), 
                          vbleSelec = TRUE, # indicates if a variable selection is done 
                          crit.varsel = "BIC")
res_with_C <- VarSelCluster(x_C, 
                          gvals = 1:ncol(x_C), 
                          vbleSelec = TRUE,
                          crit.varsel = "BIC")


```

Comparison of the BIC for both models: variable selection permits to improve the BIC
```{r, comment="", warning=FALSE}
## Varari
BIC(res_without_V) # this is lower
BIC(res_with_V) 

## Cabral
BIC(res_without_C) # this is lower
BIC(res_with_C) 
```

No Variable Selection yielded a lower BIC value for both sites, so I'll carry on with no VS for the remainder of this analysis.


Evaluation of the partition accuracy: Adjusted Rand Index (ARI) is computed between the true partition (ztrue) and its estimators.
The expectation of ARI is zero if the two partitions are independent. 
The ARI is equal to one if the partitions are equals.
Variable selection permits to improve the ARI.
Note that ARI cannot be used for model selection in clustering, because there is no true partition.

Partition near 0 indicates that the clusters are very related to the Plate_Seep factors we related the matrix to.
Can compare other factors in the future (ie. bacteria communities or coral counts, etc.)
```{r, comment="", warning=FALSE}
## Varari
ARI(ztrue_V, fitted(res_without_V))
## Cabral
ARI(ztrue_C, fitted(res_without_C))

```

To obtained the partition and the probabilities of classification
```{r, comment="", warning=FALSE}
# Estimated partition
V_cluster<-fitted(res_without_V)
C_cluster<-fitted(res_without_C)

# Estimated probabilities of classification
head(fitted(res_without_V, type="probability"))
head(fitted(res_without_C, type="probability"))
```

To get a summary of the selected model.
```{r, comment="", warning=FALSE}
# Summary of the best model
summary(V_cluster)
summary(C_cluster)

summary(res_without_V) # 2 clusters
summary(res_without_C) # 4 clusters
```


Distribution of the most discriminative variable per clusters
```{r, comment="", warning=FALSE}
# Boxplot for the continuous variable MaxHeartRate

Vdes<-plot(x = res_without_V, y = 1:ncol(x_V))
Cdes<-plot(x = res_without_C, y = 1:ncol(x_C))

#ggsave(here("Output","DiscriminativePower_Varari_TransScale.png"),Vdes, height = 10, width = 10)
#ggsave(here("Output","DiscriminativePower_Cabral_TransScale.png"),Cdes, height = 10, width = 10)

Vdes
Cdes
```

Example empirical and theoretical distributions of the most discriminative variable (to check that the distribution is well-fitted)
```{r, comment="", warning=FALSE}
# Empirical and theoretical distributions (to check that the distribution is well-fitted)

plot(res_without_V, y="Salinity", type="cdf")
plot(res_without_C, y="Silicate_umolL", type="cdf")

```

Distribution of a categorical variable per clusters
(when we have categorical)
```{r, comment="", warning=FALSE}
# Summary of categorical variable
# plot(res_with, y="Shore_Habitat")
```

To have details about the selected model
```{r, comment="", warning=FALSE}
# More detailed output
print(res_without_V)
print(res_without_C)
```

To print the parameters
```{r, comment="", warning=FALSE}
# Print model parameter
coef(res_without_C)
coef(res_without_V)
```


```{r, comment="", warning=FALSE, eval=F, echo=F}
# Probabilities of classification for new observations 
#(I don't know what this is)

# Probabilities of classification for new observations 
# predict(res_with, newdata = x[1:3,])
```



### Graph

Add site locations to cluster value df
```{r, warning=FALSE}
# make cluster vector dataframe type to join to full_data
V_cluster<-as.data.frame(V_cluster)
C_cluster<-as.data.frame(C_cluster)

# join cluster ID's to full_data
V_Cluster_data<-V_data %>% 
  cbind(V_cluster) %>% 
  mutate(V_cluster = as.factor(V_cluster))
C_Cluster_data<-C_data %>% 
  cbind(C_cluster) %>% 
  mutate(C_cluster = as.factor(C_cluster))

```  

*Map Clusters*
Create Base Maps for Varari and Cabral
```{r}
# mean lat and long for the maps
MeanGPS <- Full_data %>%
  group_by(Location) %>% # varari vs cabral
  summarise(lon = median(lon, na.rm = TRUE),
            lat = median(lat, na.rm = TRUE))

SiteGPS <- Full_data %>%
  group_by(Location, CowTagID) %>%
  summarise(lon = mean(lon, na.rm = TRUE),
            lat = mean(lat, na.rm = TRUE))


# Varari
VarariBaseMap<-get_map(MeanGPS %>% filter(Location == "Varari") %>% select(lon,lat), maptype = 'satellite', zoom = 18)
# Cabral
CabralBaseMap<-get_map(MeanGPS %>% filter(Location == "Cabral") %>% select(lon,lat), maptype = 'satellite', zoom = 18)
```

```{r, warning=FALSE}

  ### Map Varari clusters
cluster_varari_map <- ggmap(VarariBaseMap) +
  geom_point(data = V_Cluster_data,
             aes(x = lon, y = lat,
                 color = V_cluster),
            size = 3) + # set alpha and color aesthetics
  # scale_color_manual(values = pnw_palette("Moth", 4)) +
  labs(x = "Longitude", y = "Latitude",  #label x and y axes
        title = "Varari, Clusters (LCM) \n Transformed and Scaled")

#ggsave(here("Output","SGDZones","Varari","Varari_Cluster_Map_TransScale.png"),cluster_varari_map,height = 10, width = 10)

cluster_varari_map

```

```{r, warning=FALSE}

  ### Map Cabral clusters
cluster_cabral_map <- ggmap(CabralBaseMap) +
  geom_point(data = C_Cluster_data,
             aes(x = lon, y = lat,
                 color = C_cluster),
            size = 3) + # set alpha and color aesthetics
  # scale_color_manual(values = pnw_palette("Moth", 4)) +
  labs(x = "Longitude", y = "Latitude",  #label x and y axes
        title = "Cabral, Clusters (LCM) \n Transformed and Scaled")

#ggsave(here("Output","SGDZones","Cabral","Cabral_Cluster_Map_TransScale.png"),cluster_cabral_map,height = 10, width = 10)

cluster_cabral_map

```



*Create boxplot faceted by clusters*
```{r, warning=FALSE}

### Create boxplot faceted by clusters
#First, pivot longer
V_cluster_long <- V_Cluster_data %>%
  pivot_longer(cols = c(Salinity:N_percent),
               names_to = "Nutrient_parameters",
               values_to = "Nutrient_values")

Vbox<-ggplot(V_cluster_long, 
              mapping = aes(x = Nutrient_parameters,
                            y= Nutrient_values, 
                            color = V_cluster)) +
  geom_boxplot()+
  #coord_trans(y = "log") +
  facet_wrap(~V_cluster)  +
  ylab("Concentration") +
  xlab("") +
  theme(axis.text.x = element_text(angle = 90, vjust = -.1))
  # scale_color_manual(values = pnw_palette("Moth", 5))

C_cluster_long <- C_Cluster_data %>%
  pivot_longer(cols = c(Salinity:N_percent),
               names_to = "Nutrient_parameters",
               values_to = "Nutrient_values")

Cbox<-ggplot(C_cluster_long, 
              mapping = aes(x = Nutrient_parameters,
                            y= Nutrient_values, 
                            color = C_cluster)) +
  geom_boxplot()+
  #coord_trans(y = "log") +
  facet_wrap(~C_cluster)  +
  ylab("Concentration") +
  xlab("") +
  theme(axis.text.x = element_text(angle = 90, vjust = -.1))
  # scale_color_manual(values = pnw_palette("Moth", 5))

#ggsave(here("Output","SGDZones","Varari","Boxplots_Varari_TransScale.png"), Vbox, height = 10, width = 8)
#ggsave(here("Output","SGDZones","Cabral","Boxplots_Cabral_TransScale.png"), Cbox, height = 10, width = 8)

Vbox
Cbox

```



