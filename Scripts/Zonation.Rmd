---
title: "Untitled"
output: html_document
---


### Assess biogeochemistry data to examine zonation of SGD
### Created by Danielle Barnas
### Created on 1/26/2022

```{r, echo = FALSE, warning=FALSE}
## Load libraries
library(here)
library(tidyverse)
library(patchwork)

library(ggmap)
library(viridis)
library(maptools)
library(kriging)
library(ggnewscale)
library(wql)
library(glue)
library(gridExtra)
library(curl)
```

```{r}
# Avoid scientific notation throughout
options(scipen=999)
```

```{r}
## Read in data from github repository url
AllChemData<-read_csv(curl('https://raw.githubusercontent.com/njsilbiger/MooreaSGD_site-selection/main/Data/August2021/Allbiogeochemdata_QC.csv'))
head(AllChemData)
```

```{r}
## Pivot datatable to long form, grouping biogeochemical parameters in one column
LongChemData<-AllChemData %>% 
  pivot_longer(cols = 14:28, names_to = "Parameters", values_to = "Values")
```

```{r}
## Summarise biogeochemical parameter data by Location: mean, min, max, sd
SummaryChemData<-LongChemData %>% 
  group_by(Location,Parameters) %>% 
  summarise(Mean = mean(Values, na.rm = T), # get summary statistics from each site per parameter
            Maximum = max(Values, na.rm = T),
            Minimum = min(Values, na.rm = T),
            StDev = sd(Values, na.rm=T))
SummaryChemData
```


```{r, warning=FALSE}
# Comparing Parameters
ReducedChemData<-AllChemData %>% 
  select(1:21) %>% # removes unwanted parameters
  filter(Plate_Seep != "Well") %>% # only uses fringing reef sample points
  pivot_longer(cols = 14:21, names_to = "Parameters", values_to = "Values") %>% 
  group_by(Location, DateTime, Parameters) %>% 
  summarise(Mean = mean(Values, na.rm = T), # get summary statistics from each Location and sampling time (tide and day/night) per parameter
            Maximum = max(Values, na.rm = T),
            Minimum = min(Values, na.rm = T),
            StDev = sd(Values, na.rm=T))
ReducedChemData %>% 
  ggplot(aes(x = DateTime, y = Mean)) +
  geom_point() + 
  geom_line() +
  facet_wrap(~Parameters, scales = "free")
```

Apparent trends are as follows:  
- Phosphate, TA, Silicate, NN all directly related to each other and inversely related to Salinity and pH
- Salinity and Silicate and strongly inversely related
- Salinity and Phosphate are strongly inversely related


```{r, warning = FALSE}
# need to assess Parameters at each point
LongChemData %>% 
  filter(Plate_Seep != "Well",
         Location == "Varari", # choose just varari for now
         Parameters == "pH",  # process for each parameter
         Tide == "Low") %>% 
         #Day_Night == "Night") %>% # most extreme biogeochemical conditions
  lm(Values ~ CowTagID, data = .) %>% 
  summary()
```
<b>Low Tide Samples:</b>  
Silicate: VSeep, r2 = 0.6381  
Phosphate: VSeep, r2 = 0.5745  
Salinity: VSeep, r2 = 0.6313  
TA: VSeep, r2 = 0.6423  
pH: VSeep, r2 = 0.5511  
- Variability of p-values:  
    - Seep < 0.05  
    - V19 (0.395), V16 (0.506), V4 (0.589), V8 (0.623)  
    - V10 (0.707), V3 (0.717), V9 (0.719)  
NN: VSeep, r2 = 0.5542  
Ammonia: V2, r2 = 0.2751  
  
<b>Low Day Samples:</b>  
Silicate: NS  
Phosphate: NS  
Salinity: VSeep, r2 = 0.4238  
TA: NS  
pH: NS  
NN: NS  
Ammonia: NS  
  
<b>All Tide D_N Samples:</b>  
Silicate: NS  
Phosphate: VSeep, r2 = 0.3159  
Salinity: NS  
TA: VSeep, r2 = 0.4078  
pH: VSeep, r2 = 0.3667  
NN: VSeep, r2 = 0.3000  
Ammonia: V2, r2 = 0.1856  


### Plots displaying biogeochem

Create Base Maps for Varari and Cabral
```{r}
# mean lat and long for the maps
MeanGPS<-AllChemData %>%
  filter(Location != "Offshore")%>%
  group_by(Location) %>%
  summarise(lon = median(lon, na.rm = TRUE),
            lat = median(lat, na.rm = TRUE))

SiteGPS<-AllChemData %>%
  filter(Location != "Offshore")%>%
  group_by(Location, CowTagID) %>%
  summarise(lon = mean(lon, na.rm = TRUE),
            lat = mean(lat, na.rm = TRUE))

# Base Maps
API<-names(read_table(here("Data","API.txt")))
register_google(key = API) ### uses my API in separate txt file

# Varari
VarariBaseMap<-get_map(MeanGPS %>% filter(Location == "Varari") %>% select(lon,lat), maptype = 'satellite', zoom = 18)
# Cabral
CabralBaseMap<-get_map(MeanGPS %>% filter(Location == "Cabral") %>% select(lon,lat), maptype = 'satellite', zoom = 18)
```

Make a spatial kriging file with polygon layers
```{r}
### Bring in the polygons for the sites
#Varari
V_kml <- getKMLcoordinates(kmlfile=here("Data","Polygons","Varari_Polygon.kml"), ignoreAltitude=T)
#Cabral
C_kml <- getKMLcoordinates(kmlfile=here("Data","Polygons","Cabral_polygon.kml"), ignoreAltitude=T)
```


Get the data ranges for all variables
```{r}
DataRange <- AllChemData %>%
  filter(Plate_Seep == "Plate") %>% # avoid seep measurements
  select(-Temperature) %>% 
  select(-c(M_C:Lignin_Like)) %>% # remove unnecessary parameters
  group_by(Location) %>% 
  summarise_if(is.numeric, range, na.rm = TRUE) %>% # yields the minimum and maximum values
  ungroup() %>%
  mutate(min_max = c("min","max","min","max")) %>% # labels rows as min or max values
  pivot_longer(cols = Salinity:Ammonia_umolL, names_to = "Parameters", values_to = "Values") %>%
  pivot_wider(names_from = min_max, values_from = Values) %>%
  select(Location, Parameters, min, max)

mins<-DataRange %>%
  filter(is.na(max)) %>%
  select(-max)

maxs<-DataRange %>%
  filter(is.na(min)) %>%
  select(-min)

min_max<-left_join(mins,maxs)
min_max
```

Create function to set up the data for kriging map
Assign lat, lon, and parameter values to dataframe (could not get kriging() to run outside of the function build, so using full krig_function layout from Nyssa's code)
```{r}
Krig_function <-function(dat_in = data, Lat = "lat", Lon = "lon", Param = "Values", poly ) {
  
  dat <- dat_in[,c(Lon, Lat, Param)]
  names(dat) <- c('Lon', 'Lat', 'Param') 
  
  dat<-dat%>%
  drop_na()

  x <- dat$Lon
  y <- dat$Lat
  z <-dat$Param

  krig1 <- kriging(x, y, z, pixels=500,polygons=poly, lags = 3) ###pixels controls how fine or course you want the prediction data frame to be
  krig2 <- krig1$map
  return(krig2)
}

# And do it "safely"
Krig_function_safe<-safely(Krig_function) # skip the NAs without breaking the code
```



Create function to plot the kriging maps
```{r}
# plot map function
V_krig_map<-function(datakrig=preds){

  ggmap(VarariBaseMap)+
    geom_point(data=datakrig, aes(x=x, y=y, colour=pred), size=4, alpha=0.5) + 
    # geom_point(data = VData, aes(x=lon, y=lat))+
    scale_color_viridis_c(" ", option = "plasma")+
    coord_sf() +
    theme(axis.line=element_blank(),
          axis.text.x=element_blank(),
          axis.text.y=element_blank(),
          axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank()) +  
    theme(panel.grid.major = element_line(color = 'white', linetype = "dashed",size = 0.5),
          plot.background=element_rect(fill='white'))+
    ggtitle(glue("Varari: {.y}")) 
 #   ggtitle(paste("Varari",DN, TD))
}
```


Nest by parameters, tides, day/night, date, etc for *Varari*
```{r, warning = FALSE}
# nest by all parameters, tides, day/Night, Date, etc to make it easy to plot all types of maps
# Varari
Varari_kriging<-AllChemData %>%
  select(-Temperature) %>% # this is temporary until we get the temperature data entered
  select(-c(M_C:Lignin_Like)) %>% # remove unnecessary parameters
  filter(Plate_Seep == "Plate", # only plot the plates because the seep samples skew the maps
         Location == "Varari",
         Tide == "Low") %>% # for now just want to see the stronger signals
  droplevels() %>%
  pivot_longer(cols = Salinity:Ammonia_umolL, names_to = "Parameters", values_to = "Values") %>%
  select(lat, lon, Tide, Day_Night, Date, Parameters, Values) %>% # select the values that are important for the kriging
  group_nest(Tide, Day_Night, Date, Parameters) %>% # the parameters to group by
 # left_join(min_max)%>% # add in the mins and max values for the plots
  mutate(preds = map(data, ~Krig_function_safe(dat_in = .x, poly = V_kml)), # run the function for every nested group
      #   preds = map(preds, head, -1), # remove the error column
       #  preds = map(preds, flatten_df), # flatten back to a tibble 
 # mutate(preds = unlist(preds))
         longname = paste(Parameters, Day_Night, Tide, Date),
         plots = map2(preds, longname, ~ggmap(VarariBaseMap)+
                        geom_point(data=.x$result, aes(x=x, y=y, colour=pred), size=4, alpha=0.5) + 
                         geom_point(data = SiteGPS %>% filter(Location == 'Varari'), aes(x=lon, y=lat)) +
                        scale_color_viridis_c(" ", option = "plasma")+
                        coord_sf() +
                        theme(axis.line=element_blank(),
                              axis.text.x=element_blank(),
                              axis.text.y=element_blank(),
                              axis.ticks=element_blank(),
                              axis.title.x=element_blank(),
                              axis.title.y=element_blank()) +  
                        theme(panel.grid.major = element_line(color = 'white', linetype = "dashed",size = 0.5),
                              plot.background=element_rect(fill='white')) +
                        ggtitle(glue("Varari: {.y}"))))
                        #ggsave(here("Output","SGDZones", glue("Varari: {.y}.png")),plot))) doesn't run with this line

```


Nest by parameters, tides, day/night, date, etc for *Cabral*
```{r, warning = FALSE}
### Cabral #####
Cabral_kriging<-AllChemData %>%
  select(-Temperature)%>% # this is temporary until we get the temperature data entered
  select(-c(M_C:Lignin_Like)) %>% # remove unnecessary parameters
  filter(Plate_Seep == "Plate", # only plot the plates because the seep samples skew the maps
         Location == "Cabral",
         Tide == "Low") %>% # for now just want to see the stronger signals
  droplevels()%>%
  pivot_longer(cols = Salinity:Ammonia_umolL, names_to = "Parameters", values_to = "Values") %>%
  select(lat, lon, Tide, Day_Night, Date, Parameters, Values) %>% # select the values that are important for the kriging
  group_nest(Tide, Day_Night, Date, Parameters) %>% # the parameters to group by
  # left_join(min_max)%>% # add in the mins and max values for the plots
  mutate(preds = map(data, ~Krig_function_safe(dat_in = .x, poly = C_kml)), # run the function for every nested group
         #   preds = map(preds, head, -1), # remove the error column
         #  preds = map(preds, flatten_df), # flatten back to a tibble 
         # mutate(preds = unlist(preds))
         longname = paste(Parameters, Day_Night, Tide, Date),
         plots = map2(preds, longname, ~ggmap(CabralBaseMap)+
                        geom_point(data=.x$result, aes(x=x, y=y, colour=pred), size=4, alpha=0.5) + 
                        geom_point(data = SiteGPS %>% filter(Location == 'Cabral'), aes(x=lon, y=lat))+
                        scale_color_viridis_c(" ", option = "plasma")+
                        coord_sf() +
                        theme(axis.line=element_blank(),
                              axis.text.x=element_blank(),
                              axis.text.y=element_blank(),
                              axis.ticks=element_blank(),
                              axis.title.x=element_blank(),
                              axis.title.y=element_blank()) +  
                        theme(panel.grid.major = element_line(color = 'white', linetype = "dashed",size = 0.5),
                              plot.background=element_rect(fill='white'))+
                        ggtitle(glue("Cabral: {.y}"))))
```



```{r, warning = FALSE}

for(i in 1:length(Varari_kriging$plots)){
  try({
  ggsave(plot = Varari_kriging$plots[[i]], file = here("Output","SGDZones","Varari",paste0(i,".png")))}, silent = TRUE)
}    

for(i in 1:length(Cabral_kriging$plots)){
  try({
  ggsave(plot = Cabral_kriging$plots[[i]], file = here("Output","SGDZones","Cabral",paste0(i,".png")))}, silent = TRUE)
}                     

```
End of script.

















```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

